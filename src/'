#ifndef GALOIS2N_HPP
#define GALOIS2N_HPP

#include "definteger.hpp"
#include <iostream>

namespace g2arithm {
// Galois 2 polynomials represented by integers viewed as 0-1 sequences
// 
// Note: The lower the G2 polynomial's order, the smaller the Int number.
//       if Order(a) > order(b) <=> a>b && a^b > b;  (^ for bitwise xor)
//       meanwhile if order(a) == order(b) <=> order(a^b) < order(b);
// Node: Both + and - for GF2 polynomials are bitwise XOR


// Long division on Galois 2 field polynomials i.e. a and b:
// @target q, r: a = qb + r, where order(r) < order(b)
  void g2longdiv(Int a, Int b, Int &q, Int &r) {
    q = 0;
    r = a;
    if (a < 0 || b <= 0) {
      std::cerr << std::string("What sort of polynomials are given ???\n");
      return;
    }

    Int b1 = b;
    while (b1 < a ) {
      Int b1m = b1 << 1;
      if (b1m > b1)
	b1 = b1m;
      else
	break;
    }

    for (; b1 >= b; b1 >>= 1) { // Right-shift b1 until the original b
      q <<= 1;
      // q is even, and a = q * b1 + r,
      //  where order(r) <= order(b1).
      // The above = holds iff. r ^ b1 < r;
      Int r1 = r ^ b1;
      if (r1 < r) {
        r = r1;    // r <<- r - b1
        q = q | 1; // q <<- q + 1
      } 
      // a = q * b1 + r is constantly satisfied,
      // while r is conditionally shrinked
      // so that order(r) < order(b1) is now satisfied.
    }
  }

  Int g2mul(Int a, Int b) {
    Int result = 0;
    // return: a * b + result
    for (; b > 0; (b >>= 1) && (a <<= 1)) {
      if (b & 1)
        result ^= a;
    }
    return result;
  }

  // Polynomials a(x) * b(x) (mod m(x)) in Galois-2 field:
  Int g2modmul(Int a, Int b, Int m) {
    assert(0 <= a && (a ^ m) > a);
    assert(0 <= b && (b ^ m) > b);

    if (a < b) {
      std::swap(a, b);
    }
    
    Int result = 0; // a * b + result (mod m)
    auto modstep= [&](Int &x) -> bool {
      if ((x ^ m) < x) {
        x ^= m;
	return 1;
      }
      return 0;
    };
    while (b) {
      if (b & 1) {
        result ^= a;
	modstep(result);
      }
      (b >>= 1) && (a <<= 1) && modstep(a);
      // $ a * b + result $ Keeps unchanged...
    }
    return result;
  }

  void exgcd(Int p1, Int p2, Int &r, Int &u1, Int &u2) {
    if (p2 == 0) {
      r = p1;
      u1 = 1;
    }
    else {
      Int k = 0, p1r = p1;
      g2longdiv(p1, p2, k, p1r);
      exgcd(p2, p1r, r, u2, u1);
      // u1 * (p1 - k * p2) + u2 * p2 = r
      u2 ^= g2mul(u1, k);
    }
  }

  template <Int order> struct GF2n {
    static const constexpr Int n = order;
    static const Int modmask;
    // size of the field, an overflow mask as well:
    static const constexpr Int size = Int(1) << order;
    static const GF2n gen;

    // a polynomial with binary associates represented as an integer:
    Int plnm;
    GF2n(Int n) {
      Int k;
      g2longdiv(n, modmask, k, plnm);
    }
    GF2n() : GF2n(0) {}

    GF2n operator+(const GF2n f1) const {
      return GF2n(plnm ^ f1.plnm);
    }

    GF2n operator-(const GF2n f1) const {
      return GF2n(plnm ^ f1.plnm);
    }

    GF2n operator*(const GF2n f1) const {
      return g2modmul(plnm, f1.plnm, modmask);
    }

    GF2n inv() const {
      Int r, u1 = 1, u2 = 0;
      exgcd(plnm, modmask, r, u1, u2);
      return GF2n(u1);
    }

    GF2n operator/(const GF2n f1) {
      return *this * f1.inv();
    }

    operator std::string() {
      char outcome[order];
      Int mask = 1;
      char *c = outcome + (order - 1);
      for (; c >= outcome; --c) {
	*c = '0' + bool(plnm & mask);
	mask <<= 1;
      }
      return std::string(outcome);
    }

    static void test() {
      using namespace std;
      cout << "Testing class GF(2^" << order << ")\n";
      
      GF2n p(1) ;
      for (int i = 0; i <= size; ++i) {
        cout << " i = " << i << " \t Poly = " << p.plnm << " = \t"
             << std::string(p) << endl;
        p = p * gen;
	if (p.plnm == 1) {
	  cout<<"p = id element = "<<string(p)<<endl;
          break;
	}
      }

      for (int i = 1; i < 100; i++) {
        GF2n p1(i), p2 = p1.inv();
        cout << string(p1) << " * \t " << string(p2) << "  = \t"
             << string(p1 * p2) << endl;
      }

      {
	cout<<"Test that a**2 + b**2 = (a + b) ** 2 \n  Please Insert a & b  as integers:";
	Int a, b;
        cin >> a >> b;
        GF2n pa = GF2n(a), pb = GF2n(b);
        cout << "pa   = " << string(pa) << endl;
        cout << "pa^2 = " << string(pa * pa) << endl;
        cout << "pb   = " << string(pb) << endl;
        cout << "pb^2 = " << string(pb * pb) << endl;
        cout << "pa + pb = " << string(pa + pb) << endl;
        cout << "pa^2 + pb^2 = " << string(pa * pa + pb * pb) << endl;
        cout << "(pa + pb)^2 = " << string((pa + pb) * (pa + pb)) << endl;
      }
    }
  };
  template <> const Int GF2n<8>::modmask = 283;
  template <> const GF2n<8> GF2n<8>::gen = 15;
}

#endif
